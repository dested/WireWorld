{"version":3,"sources":["assembly/index.ts"],"names":[],"mappings":"4FAiCE,AAAY,YAKZ,UACK,AAAiB,MAAtB,EAAyB,OAEvB,AAAyB,AADzB,AAAsB,wBAEjB,AAAY,MAAjB,EAAoB,OAGhB,AAAS,AAFX,wCAGE,AAAS,kBADT,IAEA,AAAS,kBAHX,IAKE,AAAoB,IACpB,AAA0B,UACrB,AAAY,MAAjB,EAAoB,OAElB,AAAI,AAlC6B,AAAxB,AAkCG,AAxBL,YAA2B,eAVf,MAkC2B,KAE5C,AAAI,AADJ,OACsB,KACpB,AAAgB,IAChB,IAN+B,WAUrC,AAAI,EAAgB,KACT,gCAET,AAAoB,EAAoB,OAtBV,WAHE,WAfxC","sourceRoot":"assemblyscript:///","sourceContents":["/// <reference path=\"../../../node_modules/assemblyscript/index.d.ts\" />\n\n// @external('console', 'logger')\n// declare function logger(offset: usize): void;\n\nconst copperLen: u32 = 8;\nconst size = 605129;\nconst arrLen = 7000;\nconst coppersSize = size * copperLen;\nconst headsArrayOffset = coppersSize + size;\nconst headsGridOffset = headsArrayOffset + arrLen;\nconst tailsArrayOffset = headsGridOffset + size;\nconst tailsGridOffset = tailsArrayOffset + arrLen;\n\nconst newHeadsArrayOffset = tailsGridOffset + size;\nconst newHeadsGridOffset  = newHeadsArrayOffset + arrLen;\n\n@inline\nfunction loadBit(offset: u32): u32 {\n  return load<u32>(offset << alignof<u32>());\n}\n\n@inline\nfunction storeBit(offset: u32, value: u32): void {\n  store<u32>(offset << alignof<u32>(), value);\n}\n\n@inline\nfunction loadCopper(offset: u32, pos: u8): u32 {\n  return loadBit(offset * copperLen + pos + 1);\n}\n\nexport function init(): void {\n  memory.grow(800);\n}\n\nexport function tick(): void {\n  let newHeadArrayIndex = 0;\n  let hLen = loadBit(headsArrayOffset);\n  for (let index: u32 = 1; index <= hLen; ++index) {\n    let headKey = loadBit(headsArrayOffset + index);\n    let hCopperLen = loadBit(headKey * copperLen);\n    for (let i: u8 = 0; i < hCopperLen; ++i) {\n      let copperStateIndex = loadCopper(headKey, i);\n      if (\n        !loadBit(tailsGridOffset + copperStateIndex) &&\n        !loadBit(headsGridOffset + copperStateIndex) &&\n        !loadBit(newHeadsGridOffset + copperStateIndex)\n      ) {\n        let headNeighbors = 0;\n        let hnCopperLen = loadBit(copperStateIndex * copperLen);\n        for (let j: u8 = 0; j < hnCopperLen; ++j) {\n          let stateIndex = loadCopper(copperStateIndex, j);\n          if (loadBit(headsGridOffset + stateIndex) === 1) {\n            ++headNeighbors;\n            if (headNeighbors === 3) {\n              headNeighbors = 0;\n              break;\n            }\n          }\n        }\n        if (headNeighbors > 0) {\n          storeBit(newHeadsGridOffset + copperStateIndex, 1);\n          storeBit(newHeadsArrayOffset + newHeadArrayIndex + 1, copperStateIndex);\n          newHeadArrayIndex = newHeadArrayIndex + 1;\n        }\n      }\n    }\n  }\n  storeBit(newHeadsArrayOffset, newHeadArrayIndex);\n}\n"]}