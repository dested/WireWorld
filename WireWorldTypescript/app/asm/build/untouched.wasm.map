{"version":3,"sources":["assembly/index.ts"],"names":[],"mappings":"8KAiCE,AAAY,YAIZ,AAAwB,IACxB,AAAW,EAAQ,eACnB,EAAK,AAAiB,MAAG,EAAS,MAAe,EAC/C,AAAc,EAAQ,EAAmB,gBACzC,AAAiB,EAAQ,EAAU,gBACnC,EAAK,AAAa,MAAG,EAAI,MAAiB,EACxC,AAAuB,6BACvB,AACE,AAAC,EAAQ,EAAkB,mBAC3B,AAAC,EAAQ,EAAkB,0BAC3B,AAAC,EAAQ,EAAqB,wBAE9B,AAAoB,IACpB,AAAkB,EAAQ,EAAmB,gBAC7C,EAAK,AAAa,MAAG,EAAI,MAAkB,EACzC,AAAiB,EAvBkB,EAA5B,EAAS,GAAY,GAAM,iBAwBlC,AAAI,EAAQ,EAAkB,KAlCG,AAAxB,EAAU,OAkC2B,KAC5C,AAAE,OACF,AAAI,EAAkB,KACpB,AAAgB,IAChB,KANgC,AAAE,aAUxC,AAAI,EAAgB,KACT,EAAqB,KAAkB,cACvC,EAAsB,GAAoB,eACnD,AAAoB,EAAoB,QAtBT,AAAE,cAHD,AAAE,aA8BjC,IA7CT,AAAW,EAAU,GAAgB","sourceRoot":"assemblyscript:///","sourceContents":["/// <reference path=\"../../../node_modules/assemblyscript/index.d.ts\" />\n\n// @external('console', 'logger')\n// declare function logger(offset: usize): void;\n\nconst copperLen: u32 = 8;\nconst size = 605129;\nconst arrLen = 7000;\nconst coppersSize = size * copperLen;\nconst headsArrayOffset = coppersSize + size;\nconst headsGridOffset = headsArrayOffset + arrLen;\nconst tailsArrayOffset = headsGridOffset + size;\nconst tailsGridOffset = tailsArrayOffset + arrLen;\n\nconst newHeadsArrayOffset = tailsGridOffset + size;\nconst newHeadsGridOffset  = newHeadsArrayOffset + arrLen;\n\n@inline\nfunction loadBit(offset: u32): u32 {\n  return load<u32>(offset << alignof<u32>());\n}\n\n@inline\nfunction storeBit(offset: u32, value: u32): void {\n  store<u32>(offset << alignof<u32>(), value);\n}\n\n@inline\nfunction loadCopper(offset: u32, pos: u32): u32 {\n  return loadBit(offset * copperLen + pos + 1);\n}\n\nexport function init(): void {\n  memory.grow(800);\n}\n\nexport function tick(): void {\n  let newHeadArrayIndex = 0;\n  let hLen = loadBit(headsArrayOffset);\n  for (let index: u32 = 1; index <= hLen; ++index) {\n    let headKey = loadBit(headsArrayOffset + index);\n    let hCopperLen = loadBit(headKey * copperLen);\n    for (let i: u32 = 0; i < hCopperLen; ++i) {\n      let copperStateIndex = loadCopper(headKey, i);\n      if (\n        !loadBit(tailsGridOffset + copperStateIndex) &&\n        !loadBit(headsGridOffset + copperStateIndex) &&\n        !loadBit(newHeadsGridOffset + copperStateIndex)\n      ) {\n        let headNeighbors = 0;\n        let hnCopperLen = loadBit(copperStateIndex * copperLen);\n        for (let j: u32 = 0; j < hnCopperLen; ++j) {\n          let stateIndex = loadCopper(copperStateIndex, j);\n          if (loadBit(headsGridOffset + stateIndex) === 1) {\n            ++headNeighbors;\n            if (headNeighbors === 3) {\n              headNeighbors = 0;\n              break;\n            }\n          }\n        }\n        if (headNeighbors > 0) {\n          storeBit(newHeadsGridOffset + copperStateIndex, 1);\n          storeBit(newHeadsArrayOffset + newHeadArrayIndex + 1, copperStateIndex);\n          newHeadArrayIndex = newHeadArrayIndex + 1;\n        }\n      }\n    }\n  }\n  storeBit(newHeadsArrayOffset, newHeadArrayIndex);\n}\n"]}